<!DOCTYPE html>
<html lang="en" >
<head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GF8S00ZL6D"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GF8S00ZL6D');
</script>

  <meta charset="UTF-8">
  <title>Play Solitaire Now</title>
  <meta property="og:image" content="https://i.imgur.com/tcmz9Af.png"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel='stylesheet' href='https://bfa.github.io/solitaire-js/css/bootstrap.min.css'><link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<div class="container">

      <div id="score">
         <div class="timer">
            <button id="play-pause">
               <i id="play">Play</i>
               <i id="pause">Pause</i>
            </button>
            <label>Timer:</label>
            <span>00:00</span>
         </div>
         <div class="move-count" data-moves="0">
            <label>Moves:</label>
            <span>0</span>
         </div>
         <div class="score" data-score="0">
            <label>Score:</label>
            <span>0</span>
         </div>
      </div>

      <div id="table">

         <div class="upper-row">
            <div id="stock" class="stock pile" data-pile="stock">
               <i class="reload-icon" data-action="reload">
                  <span></span>
               </i>
               <ul></ul>
            </div>

            <div id="waste" class="waste pile" data-pile="waste">
               <ul></ul>
            </div>

            <ul id="fnd" class="fnd">
               <li id="spades" class="spades pile" data-pile="spades" data-empty="true"><ul></ul></li>
               <li id="hearts" class="hearts pile" data-pile="hearts" data-empty="true"><ul></ul></li>
               <li id="diamonds" class="diamonds pile" data-pile="diamonds" data-empty="true"><ul></ul></li>
               <li id="clubs" class="clubs pile" data-pile="clubs" data-empty="true"><ul></ul></li>
            </ul>
         </div>

         <div class="lower-row">
            <ul id="tab" class="tab">
               <li class="pile" data-pile="1"><ul></ul></li>
               <li class="pile" data-pile="2"><ul></ul></li>
               <li class="pile" data-pile="3"><ul></ul></li>
               <li class="pile" data-pile="4"><ul></ul></li>
               <li class="pile" data-pile="5"><ul></ul></li>
               <li class="pile" data-pile="6"><ul></ul></li>
               <li class="pile" data-pile="7"><ul></ul></li>
            </ul>
         </div>

      </div>

   </div><!-- /.container -->

   <button id="auto-win">Auto Win</button>

   <canvas id="confetti"></canvas>

   <ul class="template">
      <li data-rank="2">
         <div class="two {{suit}}">
            <div class="corner top">
               <span class="rank">2</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_center"></span>
            <span class="suit bottom_center"></span>
            <div class="corner bottom">
               <span class="rank">2</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="3">
         <div class="three {{suit}}">
            <div class="corner top">
               <span class="rank">3</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_center"></span>
            <span class="suit middle_center"></span>
            <span class="suit bottom_center"></span>
            <div class="corner bottom">
               <span class="rank">3</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="4">
         <div class="four {{suit}}">
            <div class="corner top">
               <span class="rank">4</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">4</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="5">
         <div class="five {{suit}}">
            <div class="corner top">
               <span class="rank">5</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit middle_center"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">5</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="6">
         <div class="six {{suit}}">
            <div class="corner top">
               <span class="rank">6</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit middle_left"></span>
            <span class="suit middle_right"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">6</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="7">
         <div class="seven {{suit}}">
            <div class="corner top">
               <span class="rank">7</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit middle_left"></span>
            <span class="suit middle_top"></span>
            <span class="suit middle_right"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">7</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="8">
         <div class="eight {{suit}}">
            <div class="corner top">
               <span class="rank">8</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit middle_left"></span>
            <span class="suit middle_top_center"></span>
            <span class="suit middle_right"></span>
            <span class="suit middle_bottom_center"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">8</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="9">
         <div class="nine {{suit}}">
            <div class="corner top">
               <span class="rank">9</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit middle_top_left"></span>
            <span class="suit middle_center"></span>
            <span class="suit middle_top_right"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <span class="suit middle_bottom_left"></span>
            <span class="suit middle_bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">9</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="10">
         <div class="ten {{suit}}">
            <div class="corner top">
               <span class="rank">10</span>
               <span class="suit"></span>
            </div>
            <span class="suit top_left"></span>
            <span class="suit top_right"></span>
            <span class="suit middle_top_left"></span>
            <span class="suit middle_top_center"></span>
            <span class="suit middle_top_right"></span>
            <span class="suit bottom_left"></span>
            <span class="suit bottom_right"></span>
            <span class="suit middle_bottom_center"></span>
            <span class="suit middle_bottom_left"></span>
            <span class="suit middle_bottom_right"></span>
            <div class="corner bottom">
               <span class="rank">10</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="J">
         <div class="jack {{suit}}">
            <div class="corner top">
               <span class="rank">J</span>
               <span class="suit"></span>
            </div>
            <span class="face middle_center"></span>
            <div class="corner bottom">
               <span class="rank">J</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="Q">
         <div class="queen {{suit}}">
            <div class="corner top">
               <span class="rank">Q</span>
               <span class="suit"></span>
            </div>
            <span class="face middle_center"></span>
            <div class="corner bottom">
               <span class="rank">Q</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="K">
         <div class="king {{suit}}">
            <div class="corner top">
               <span class="rank">K</span>
               <span class="suit"></span>
            </div>
            <span class="face middle_center"></span>
            <div class="corner bottom">
               <span class="rank">K</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
      <li data-rank="A">
         <div class="ace {{suit}}">
            <div class="corner top">
               <span class="rank">A</span>
               <span class="suit"></span>
            </div>
            <span class="suit middle_center"></span>
            <div class="corner bottom">
               <span class="rank">A</span>
               <span class="suit"></span>
            </div>
         </div>
      </li>
   </ul><!-- /.templates -->
<!-- partial -->
  <script  src="./script.js"></script>

<script>
  // Global variables for drag and drop
  var dragSrcEl = null;
  var dragData = null;
  var isDragging = false;

  // Add a global reference for the drag image
  var currentDragImage = null;

  document.addEventListener('DOMContentLoaded', function() {
    // Initialize drag and drop after the game has rendered
    setTimeout(initializeDragAndDrop, 100);
  });

  function initializeDragAndDrop() {
    // Make face-up cards in tableau draggable
    var cards = document.querySelectorAll('.tab .card.up');
    cards.forEach(function(card) {
      card.setAttribute('draggable', true);
      card.addEventListener('dragstart', handleDragStart, false);
      card.addEventListener('dragend', handleDragEnd, false);
    });
    // Make top card in waste pile draggable
    var wasteCard = document.querySelector('#waste .card.up');
    if (wasteCard) {
      wasteCard.setAttribute('draggable', true);
      wasteCard.addEventListener('dragstart', handleDragStart, false);
      wasteCard.addEventListener('dragend', handleDragEnd, false);
    }
    // Make piles droppable
    var piles = document.querySelectorAll('.pile');
    piles.forEach(function(pile) {
      pile.addEventListener('dragover', handleDragOver, false);
      pile.addEventListener('drop', handleDrop, false);
      pile.addEventListener('dragenter', handleDragEnter, false);
      pile.addEventListener('dragleave', handleDragLeave, false);
    });
    // Make foundation piles droppable
    var foundations = document.querySelectorAll('#fnd .pile');
    foundations.forEach(function(foundation) {
      foundation.addEventListener('dragover', handleDragOver, false);
      foundation.addEventListener('drop', handleDrop, false);
      foundation.addEventListener('dragenter', handleDragEnter, false);
      foundation.addEventListener('dragleave', handleDragLeave, false);
    });
  }

  // Helper to get pile index from a card element
  function getPileIndexFromCard(cardEl) {
    // Only works for tableau piles (data-pile 1-7)
    return Number(cardEl.closest('.pile').dataset.pile);
  }

  // Helper to get card index within its pile
  function getCardIndexInPile(cardEl) {
    const pileEl = cardEl.closest('.pile');
    const cards = Array.from(pileEl.querySelectorAll('.card.up'));
    return cards.indexOf(cardEl);
  }

  function handleDragStart(e) {
    if (!e.target.classList.contains('up')) {
      e.preventDefault();
      return false;
    }
    
    isDragging = true;
    dragSrcEl = e.target;
    
    // Get source pile
    const pileIndex = getPileIndexFromCard(e.target);
    let pileArr;
    let isWaste = false;
    if (e.target.closest('#waste')) {
      pileArr = table['waste'];
      isWaste = true;
    } else {
      pileArr = table['tab'][pileIndex];
    }
    // Find the index of the dragged card in the data array
    const rank = e.target.dataset.rank;
    const suit = e.target.dataset.suit;
    const cardIndex = pileArr.findIndex(card => card[0] === rank && card[1] === suit);
    if (cardIndex === -1) {
      e.preventDefault();
      return false;
    }
    // Only allow dragging if the card is face-up
    const pileEl = e.target.closest('.pile');
    const upCards = Array.from(pileEl.querySelectorAll('.card.up'));
    const upCardIndices = upCards.map(cardEl => {
      const r = cardEl.dataset.rank;
      const s = cardEl.dataset.suit;
      return pileArr.findIndex(card => card[0] === r && card[1] === s);
    });
    if (!upCardIndices.includes(cardIndex)) {
      e.preventDefault();
      return false;
    }
    // Waste pile: only allow dragging the top card
    if (isWaste) {
      if (cardIndex !== pileArr.length - 1) {
        e.preventDefault();
        return false;
      }
    }
    // Store drag data for stack movement
    dragData = {
      pileIndex,
      cardIndex,
      stack: isWaste ? [pileArr[cardIndex]] : pileArr.slice(cardIndex)
    };
    // Set up the same state as click system
    const card = [rank, suit];
    e.target.dataset.selected = 'true';
    $table.dataset.move = 'true';
    $table.dataset.selected = card;
    $table.dataset.source = pileIndex;
    // --- Custom drag image for stack (improved) ---
    // Waste: only show the top card
    let stackEls;
    if (isWaste) {
      stackEls = [e.target];
    } else {
      // Tableau: show stack from dragged card down, top card first
      const allCardsInPile = Array.from(pileEl.querySelectorAll('.card.up'));
      const dragCardIdx = allCardsInPile.indexOf(e.target);
      stackEls = allCardsInPile.slice(dragCardIdx);
    }
    // Create a container for the drag image
    const dragImage = document.createElement('div');
    dragImage.style.position = 'absolute';
    dragImage.style.pointerEvents = 'none';
    dragImage.style.zIndex = '9999';
    dragImage.style.top = '-1000px'; // offscreen
    dragImage.style.left = '-1000px';
    dragImage.style.background = 'none';
    dragImage.style.border = 'none';
    dragImage.style.opacity = '1';
    // Stack the cards visually, copying computed styles
    // For tableau: offset each card downward and layer above the previous, so the drag image matches the tableau
    const stackElsForImage = stackEls;
    // Calculate pixel offset based on the real offset between stacked cards in the tableau
    let realOffsetPx = 0;
    if (!isWaste && stackElsForImage.length > 1) {
      const first = stackElsForImage[0];
      const second = stackElsForImage[1];
      const firstTop = first.getBoundingClientRect().top;
      const secondTop = second.getBoundingClientRect().top;
      realOffsetPx = Math.abs(secondTop - firstTop);
    } else if (stackElsForImage.length > 0) {
      // Fallback: use 15.5em converted to px based on card's font size
      const fontSize = parseFloat(window.getComputedStyle(stackElsForImage[0]).fontSize) || 16;
      realOffsetPx = 15.5 * fontSize;
    } else {
      realOffsetPx = 50; // fallback
    }
    stackElsForImage.forEach((cardEl, i) => {
      const clone = cardEl.cloneNode(true);
      const computed = window.getComputedStyle(cardEl);
      clone.style.width = computed.width;
      clone.style.height = computed.height;
      clone.style.background = computed.background;
      clone.style.backgroundColor = computed.backgroundColor;
      clone.style.border = computed.border;
      clone.style.borderRadius = computed.borderRadius;
      clone.style.boxShadow = computed.boxShadow;
      clone.style.position = 'absolute';
      clone.style.top = `${i * realOffsetPx}px`;
      clone.style.left = '0px';
      clone.style.opacity = '1';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = (i + 1).toString(); // Each next card is above the previous
      dragImage.appendChild(clone);
    });
    document.body.appendChild(dragImage);
    currentDragImage = dragImage;
    // Set drag image (offset so mouse is on the top card)
    e.dataTransfer.setDragImage(dragImage, 20, 20);
    // --- End custom drag image ---

    e.target.style.opacity = '0.4';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', ''); // Required for Firefox
  }

  function handleDragOver(e) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
  }

  function handleDragEnter(e) {
    if (e.target.classList.contains('pile') || e.target.closest('.pile')) {
      var pile = e.target.closest('.pile');
      pile.classList.add('drag-over');
      
      // Check if this would be a valid drop
      if (isDragging && dragData) {
        var destPile = pile.dataset.pile;
        var selectedCard = dragData.stack[0];
        var destCard = null;
        
        // Check if dropping on a card
        var pileCards = pile.querySelectorAll('.card.up');
        if (pileCards.length > 0) {
          var topCard = pileCards[pileCards.length - 1];
          destCard = [topCard.dataset.rank, topCard.dataset.suit];
        }
        
        var validationTarget = destCard || destPile;
        var isValid = false;
        if (typeof validateMove === 'function') {
          isValid = validateMove(selectedCard, validationTarget, destPile);
        }
        
        if (isValid) {
          pile.classList.add('valid-drop');
        } else {
          pile.classList.add('invalid-drop');
        }
      }
    }
  }

  function handleDragLeave(e) {
    if (e.target.classList.contains('pile') || e.target.closest('.pile')) {
      var pile = e.target.closest('.pile');
      pile.classList.remove('drag-over', 'valid-drop', 'invalid-drop');
    }
  }

  function clearSelectionAndMoveState() {
    // Remove data-selected from all cards
    document.querySelectorAll('.card[data-selected]').forEach(card => {
      delete card.dataset.selected;
    });
    // Remove move state from table
    var table = document.querySelector('#table');
    if (table) {
      delete table.dataset.move;
      delete table.dataset.selected;
      delete table.dataset.source;
      delete table.dataset.dest;
    }
  }

  function handleDrop(e) {
    // Defensive: check dragData
    if (!dragData || !dragData.stack) {
      clearSelectionAndMoveState();
      return false;
    }
    // Find destination pile
    const targetPileEl = e.target.closest('.pile');
    if (!targetPileEl) {
      clearSelectionAndMoveState();
      return false;
    }
    const destPileIndex = Number(targetPileEl.dataset.pile);
    const destPileName = targetPileEl.dataset.pile;
    $table.dataset.dest = destPileIndex;

    // Check if this is a foundation pile (not a number)
    let destPileArr;
    const isFoundation = isNaN(destPileIndex);
    if (isFoundation) {
      if (!table[destPileName]) table[destPileName] = [];
      destPileArr = table[destPileName];
    } else {
      destPileArr = table['tab'][destPileIndex];
    }

    let destCard = null;
    if (destPileArr && destPileArr.length > 0) {
      destCard = destPileArr[destPileArr.length - 1]; // Only [rank, suit]
    }
    // Use only [rank, suit] for validation
    const selectedCard = dragData.stack[0];
    let valid = false;
    // Use the same logic as double-click for foundation moves
    if (isFoundation) {
      valid = validateMove(selectedCard, destPileName, destPileName);
    } else if (destCard) {
      valid = validateMove(selectedCard, destCard, destPileName);
    } else {
      valid = validateMove(selectedCard, destPileIndex, destPileName);
    }
    if (valid) {
      if (typeof pushUndoState === 'function') pushUndoState();
      let stack;
      if (isFoundation) {
        // Only move the top card for foundation
        if (dragSrcEl && dragSrcEl.closest('#waste')) {
          stack = table['waste'].splice(dragData.cardIndex, 1);
        } else {
          stack = [table['tab'][dragData.pileIndex].splice(dragData.cardIndex, 1)[0]];
        }
        table[destPileName].push(...stack);
      } else {
        if (dragSrcEl && dragSrcEl.closest('#waste')) {
          stack = table['waste'].splice(dragData.cardIndex, 1);
        } else {
          stack = table['tab'][dragData.pileIndex].splice(dragData.cardIndex);
        }
        table['tab'][destPileIndex].push(...stack);
      }
      render(table, playedCards);
    }
    clearSelectionAndMoveState();
    return false;
  }

  function handleDragEnd(e) {
    isDragging = false;
    dragSrcEl = null;
    dragData = null;
    e.target.style.opacity = '1';
    document.querySelectorAll('.pile').forEach(pile => {
      pile.classList.remove('drag-over', 'valid-drop', 'invalid-drop');
    });
    clearSelectionAndMoveState();
    // Remove the drag image if it exists
    if (currentDragImage && currentDragImage.parentNode) {
      currentDragImage.parentNode.removeChild(currentDragImage);
      currentDragImage = null;
    }
    // Re-bind all events and restore stock pile functionality
    if (typeof play === 'function') play(table);
  }

  // Re-initialize drag and drop when cards are updated
  function updateDragAndDrop() {
    // Remove existing drag listeners
    var cards = document.querySelectorAll('.card[draggable="true"]');
    cards.forEach(function(card) {
      card.removeEventListener('dragstart', handleDragStart);
      card.removeEventListener('dragend', handleDragEnd);
      card.removeAttribute('draggable');
    });

    // Re-initialize after a short delay
    setTimeout(initializeDragAndDrop, 50);
  }

  // Override the render function to update drag and drop
  var originalRender = window.render;
  if (originalRender) {
    window.render = function(table, playedCards) {
      originalRender(table, playedCards);
      updateDragAndDrop();
    };
  }

  // 1. Ensure mobile drag-and-drop (touch events) is always enabled and re-bound after render
  function enableMobileDragAndDrop() {
    if (!('ontouchstart' in window)) return;
    let touchDragImage = null;
    let touchStartTarget = null;

    function onTouchStart(e) {
      if (!e.target.classList.contains('up')) return;
      touchStartTarget = e.target;
      handleDragStart({
        target: e.target,
        preventDefault: () => {},
        dataTransfer: {
          setData: () => {},
          effectAllowed: 'move',
          setDragImage: () => {}
        }
      });
      touchDragImage = currentDragImage;
      if (touchDragImage) {
        touchDragImage.style.display = 'block';
        touchDragImage.style.pointerEvents = 'none';
      }
      document.body.appendChild(touchDragImage);
    }

    function onTouchMove(e) {
      if (!touchDragImage) return;
      const touch = e.touches[0];
      touchDragImage.style.left = (touch.clientX - 20) + 'px';
      touchDragImage.style.top = (touch.clientY - 20) + 'px';
      e.preventDefault();
    }

    function onTouchEnd(e) {
      if (!touchDragImage) return;
      const touch = e.changedTouches[0];
      const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
      if (dropTarget) {
        handleDrop({
          target: dropTarget,
          preventDefault: () => {},
          dataTransfer: null
        });
      }
      if (touchDragImage && touchDragImage.parentNode) {
        touchDragImage.parentNode.removeChild(touchDragImage);
      }
      touchDragImage = null;
      handleDragEnd({ target: touchStartTarget });
      touchStartTarget = null;
    }

    function bindTouchListeners() {
      document.querySelectorAll('.card.up').forEach(card => {
        card.removeEventListener('touchstart', onTouchStart);
        card.removeEventListener('touchmove', onTouchMove);
        card.removeEventListener('touchend', onTouchEnd);
        card.addEventListener('touchstart', onTouchStart, { passive: false });
        card.addEventListener('touchmove', onTouchMove, { passive: false });
        card.addEventListener('touchend', onTouchEnd, { passive: false });
      });
    }
    // Always re-bind after render
    var originalRender = window.render;
    if (originalRender) {
      window.render = function(table, playedCards) {
        originalRender(table, playedCards);
        bindTouchListeners();
      };
    } else {
      bindTouchListeners();
    }
  }
  enableMobileDragAndDrop();

  // 2. Refactor #score area to use flexbox for perfect alignment of the reset button
  const scoreDiv = document.querySelector('#score');
  if (scoreDiv) {
    scoreDiv.style.display = 'flex';
    scoreDiv.style.alignItems = 'center';
    scoreDiv.style.justifyContent = 'space-between';
    scoreDiv.style.flexWrap = 'wrap';
    scoreDiv.style.gap = '0.5em';
    // Find or create the reset button
    let resetBtn = document.getElementById('reset-btn');
    if (!resetBtn) {
      resetBtn = document.createElement('button');
      resetBtn.id = 'reset-btn';
      scoreDiv.appendChild(resetBtn);
    }
    resetBtn.textContent = '⟳ Reset';
    resetBtn.style.padding = '0.5em 1.2em';
    resetBtn.style.fontSize = '1.1em';
    resetBtn.style.background = 'linear-gradient(180deg, #fff 0%, #e0e0e0 100%)';
    resetBtn.style.border = '1px solid #bbb';
    resetBtn.style.borderRadius = '8px';
    resetBtn.style.boxShadow = '0 2px 6px rgba(0,0,0,0.12)';
    resetBtn.style.cursor = 'pointer';
    resetBtn.style.fontWeight = 'bold';
    resetBtn.style.color = '#222';
    resetBtn.style.margin = '0 0 0 1em';
    resetBtn.onmouseover = function() { resetBtn.style.background = '#f5f5f5'; };
    resetBtn.onmouseout = function() { resetBtn.style.background = 'linear-gradient(180deg, #fff 0%, #e0e0e0 100%)'; };
    resetBtn.onclick = function() { location.reload(); };
    // Responsive: full width on small screens
    resetBtn.style.flexShrink = '0';
    resetBtn.style.minWidth = '100px';

    // Add Undo button
    let undoBtn = document.getElementById('undo-btn');
    // Create a button row container if not present
    let buttonRow = document.querySelector('#score .button-row');
    if (!buttonRow) {
      buttonRow = document.createElement('div');
      buttonRow.className = 'button-row';
      // Place button row as the last child of #score
      scoreDiv.appendChild(buttonRow);
    }
    // Always create or move Reset and Undo buttons into the button row
    buttonRow.appendChild(resetBtn);
    if (!undoBtn) {
      undoBtn = document.createElement('button');
      undoBtn.id = 'undo-btn';
      undoBtn.textContent = '↶ Undo';
    }
    buttonRow.appendChild(undoBtn);
    // Disable Undo if stack is empty
    function updateUndoButtonState() {
      if (window.undoStack && window.undoStack.length > 0) {
        undoBtn.disabled = false;
        undoBtn.style.opacity = '1';
        undoBtn.style.pointerEvents = 'auto';
      } else {
        undoBtn.disabled = true;
        undoBtn.style.opacity = '0.5';
        undoBtn.style.pointerEvents = 'none';
      }
    }
    undoBtn.onclick = function() { if (window.undoMove) { window.undoMove(); updateUndoButtonState(); } };
    window.updateUndoButtonState = updateUndoButtonState;
    // Call after every render
    var origRender = window.render;
    window.render = function(table, playedCards) {
      origRender(table, playedCards);
      updateUndoButtonState();
    };
    updateUndoButtonState();

    // Responsive: stack on mobile
    const style = document.createElement('style');
    style.innerHTML = `
      @media (max-width: 600px) {
        #score { flex-direction: column; align-items: stretch; }
        #reset-btn { margin: 0.5em 0 0 0; width: 100%; min-width: 0; }
      }
    `;
    document.head.appendChild(style);
  }

  // Mobile card overlap: increase vertical offset for stacked cards
  function getCardOffset() {
    return window.innerWidth <= 600 ? 5 : 3; // 5em for mobile, 3em for desktop
  }

  // After initializing undoStack and after the first pushUndoState in the game setup, call updateUndoButtonState() to ensure Undo is disabled at game start.
  if (window.updateUndoButtonState) window.updateUndoButtonState();
</script>


  
</body>
</html>
